.t troff -me
.po 1.25i
.nr sp 12
.nr pp 12
.de (C
.nf
.fp 4 H
.fp 5 HO
.fp 6 HB
.in +0.5i
.ft 6
.sz -2
.sp 1
..
.de )C
.ft 1
.sp 1
.sz +2
.in 0
.fi
.na
..
.fo ''- % -''
.sh 1 "Mappings from Concurrent C into Plain C"
.pp
This section describes the code generated by the translator for each of the
concurrent C constructs.
.sh 2 "File Header"
.pp
The translator command,
.i ccc ,
preprocesses the concurrent C program with the C preprocessor.
This is necessary because the translator accepts only plain C and concurrent
C constructs and does not understand preprocessor constructs.
Some code must be inserted at the top of the output file, however, and one
of these lines is another preprocessor command.
The code placed at the top of each output file is as follows:
.(C
#include <ccc/CC_kernel.h>
static char *DD_convert;
.)C
The include file
.i ccc/CC_kernel.h
contains type declarations and extern declarations for run time system
global data used by the generated code.
The variable \f6DD_convert\fP is the address of the large mapping table used
by the debugger.
This table is placed at the bottom of the output file.
The \f6static\fP declaration hints at future support for separate
compilation.
.sh 2 "Process Specifications"
.pp
The process spec declarations are translated into other types of
declarations.
Since the translation of transaction name delarations is more complicated,
it is handled separately.
Several pieces of information need to be stored for future use by the
translator.
Some of this, such as the types of the parameters to processes, are stored
internally in the translator.
Others, such as the number of transaction calls in a process, are stored by
creating typedefs or #defines to create names that can be reconstructed by
the translator later.
This dichotomy exists because the translator originally kept track of all
needed information using the latter style, but it resulted in code that was
very hard to read and hard to debug.
Hence, bit by bit, this information is being moved into internal tables
within the translator itself, the result being cleaner and more readable
generated code.
.pp
The procedures that are generated from process bodies return a process
identifier for the newly created process, hence that procedure must have a
forward declaration.
The code generated by virtue of the process spec, neglecting transactions,
as as follows:
.(C
process spec \f5process-type-name\fP ( \f5argument-type-list\fP );
.)C
The translation is as follows:
.(C
CC_pid CC_\f5process-type-name\fP;
#define CC_\f5process-type-name\fP_numtrans 0
.)C
In the case where transactions are specified for the process, then the zero
in the above example would be a constant indicating the number of
transactions specified.
.sh 2 "Process Specs with Transactions"
.pp
For process specifications that include the definition of transaction names,
type declarations for the tblocks are generated.
Tblocks are structures that include space for the arguments to transactions
and the return value, whether one exists or not.
Again, the method for storing information is a mix of using tables within
the translator and of generating anstract type names that can be
reconstructed later with minimal information.
A typical process transaction declaration is as follows:
.(C
trans \f5return-type\fP \f5transaction-name\fP ( \f5argument-type-list\fP );
.)C
The generated code is as follows:
.(C
typedef \f5return-type\fP CC_headvalue1;
typedef struct {
    CC_headvalue1 value;
    \f5argument-type-list\s-2\d1\u\s+2\fP arg1;
    \f5argument-type-list\s-2\d2\u\s+2\fP arg2;
    ...
} CC_\f5name-space\fP_\f5transaction-name\fP;
#define CC_\f5name-space\fP_\f5transaction-name\fP_id 0
.)C
To elaborate, the \f5argument-type-list\fP in the concurrent C construct
expands into elements within the structure declaration for the tblock.
The notation \f5argument-type-list\s-2\d1\u\s+2\fP means here the type name of the
first parameter to the transaction.
The \f5name-space\fP is an integer constant that is unique to the process
being declared and identifies a symbol table within the translator for
storing the names and types of the parameters, transactions, transaction
parameters, and transaction return values for the process.
.sh 2 "Process Body"
.pp
Process body header declarations are converted into procedure header
declarations with two additional paramaters added to the end:
one for the priority of the create statement, and another that uniquely
identifies the create statement within the program (for the debugger).
The following is a concurrent C process body header:
.(C
process body \f5process-type-name\fP ( \f5parameter-list\fP )
\f5parameter-list-declaration\fP
{
    ...
}
.)C
is translated into the following plain C code:
.(C
CC_pid CC_\f5process-type-name\fP ( \f5parameter-list\fP , CC_priority, DD_createId )
\f5parameter-list-declaration\fP
int CC_priority;
unsigned DD_createId;
{
    ...
    CC_complete();
}
.)C
.sh 2 "Process Creation"
.pp
Because process bodies are translated into procedures, the actual process
creation takes place inside the process (procedure) body rather than at the
location of the create statement.
This makes passing the parameters to the newly created process
straightforward; they are simply passed to the translated procedure as
parameters.
Hence, as show below, the create command is translated into a call to the
procedure generated by the process body declaration.
.(C
\f5process-variable\fP = create \f5process-type-name\fP ( \f5parameter-list\fP );
.)C
The translation is as follows:
.(C
\f5process-variable\fP = CC_\f5process-type-name\fP ( \f5parameter-list\fP , \f5priority\fP , \f5instance\fP );
.)C
The \f5priority\fP parameter is by default zero or the value stated after
the optional \f6with priority\fP clause.
The \f5instance\fP parameter is a serial number that uniquely identifies
this create statement in the program and is used only by the debugger.
.pp
The code at the beginning of the process body declaration is then augmented
to include a call into the run time system to perform the actual process
creation.
This is more than just a mere fork() because the internal process table for
the run time system need to be updated and the debugger must be informed.
.(C
process body \f5process-type-name\fP ( \f5parameter-list\fP )
\f5parameter-list-declaration\fP
{
     \f5local-variable-list\fP
.)C
The translation is as follows:
.(C
CC_pid CC_\f5process-type-name\fP ( \f5parameter-list\fP , CC_priority, DD_createId )
\f5parameter-list-declaration\fP
int CC_priority;
unsigned CC_createId;
{
    \f5local-variable-list\fP
    if ( CC_fork("\f5process-type-name\fP , CC_\f5process-type-name\fP_numtrans ,
        CC_priority, DD_createId, DD_convert ) )
        return CC_childpid;
.)C
.pp
The parameter \f6DD_convert\fP is the address of the large mapping table
used by the debugger.
This is the mechanism for getting its address into the run time system.
The global variable \f6CC_childpid\fP holds the process identifier of the
newly created process.
Because there is one copy of this variable for each process, no conflicts or
race conditions can exist.
.sh 2 "Simple Transaction Calls"
.pp
The code generated for the client side of transaction calls consists of four
parts: readying the run time system for the call, copying the parameters
into the tblock of the calling process, making the transaction call, and
then making the return value available as part of the transaction call
expression.
A typical transaction call is as follows:
.(C
\f5process-variable\fP.\f5transaction-name\fP ( \f5argument-list\fP );
.)C
The translation is as follows:
.(C
( CC_tcallinit ( \f5process-variable\fP , CC_\f5name-space\fP_\f5transaction-name\fP_id ) ,
  ((CC_\f5name-space\fP_\f5transaction-name\fP *)CC_mytblock)->arg\f5i\fP = \f5argument-list\s-2\di\u\s+2\fP ,
  CC_tcall ( \f5serial-number\fP ) ,
  ((CC_\f5name-space\fP_\f5transaction-name\fP *)CC_mytblock)->value );
.)C
The \f5serial-number\fP argument to \f6CC_tcall\fP uniquely identifies this
transaction call within the process body for the debugger.
The second line above is repeated for each of the arguments in the
transaction call.
As before, \f5name-space\fP is a small integer that uniquely identifies the
process being called.
The value of this compound expression is the value of the last line given
above.
.sh 2 "Timed Transaction Calls"
.pp
The translation of timed transaction calls is very similar to simple
transaction calls, except that more state needs to be saved and the value of
the call becomes a conditional expression.
A typical timed transaction call is as follows:
.(C
within \f5time\fP ? \f5process-variable\fP.\f5transaction-name\fP ( \f5argument-list\fP ) : \f5expression\fP ;
.)C
The translation is as follows:
.(C
( CC_remember_time ( f5time\fP ) ,
  CC_tcallinit ( \f5process-variable\fP , CC_\f5name-space\fP_\f5transaction-name\fP_id ) ,
  ((CC_\f5name-space\fP_\f5transaction-name\fP *)CC_mytblock)->arg\f5i\fP = \f5argument-list\s-2\di\u\s+2\fP ,
  CC_timedtcall ( \f5serial-number\fP ) ?
   ((CC_\f5name-space\fP_\f5transaction-name\fP *)CC_mytblock)->value :
   ( \f5expression\fP ) ) ) ;
.)C
.sh 2 "Accept Statements"
.pp
Simple accept statements are translated into program blocks containing a
local declaration for a transaction parameter data block (tblock), a call
into the run time system to implement the accept statement, and an explicit
treturn at the end of the compound statement following the accept statement.
The parameter variables in the accept statement are converted to references
to fields within the locally-declared tblock.
A typical accept statement is as follows:
.(C
accept \f5transaction-name\fP ( \f5argument-list\fP ) {
    \f5statement-list\fP
}
.)C
The translation is as follows:
.(C
{
    CC_tblock CC_tblock\f5id\fP;
    CC_accept ( CC_\f5name-space\fP_\f5transaction-name\fP_id ,
&CC_tblock\f5id\fP , 0 , 0 , \f5id\fP );
    {
        \f5statement-list\fP
    }
CC_warn\f5id\fP:
    CC_treturn(\f5id\fP);
CC_treturn\f5id\fP: ;
}
.)C
The first zero passed to \f6CC_accept\fP above states that this accept
statement is not within a select construct.
The second zero means that there is no \f6by\fP clause associated with this
accept statement.
